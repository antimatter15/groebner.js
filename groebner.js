var monomial = require('./monomial')
var coefficient = require('./coefficient')
var polynomial = require('./polynomial')


function s_polynomial(f, g){
    // Return S-polynomial of f and g with respect to the order.
    // S(f, g) = (lc(g)*T/lb(f))*f - (lc(f)*T/lb(g))*g,
    // where T = lcm(lb(f), lb(g)).

    var fl = polynomial.leading_term(f),
        gl = polynomial.leading_term(g);
    var t = monomial.lcm(fl[0], gl[0]);
    return polynomial.sub(polynomial.term_mul(f, [monomial.sub(t, fl[0]), gl[1]]), 
                          polynomial.term_mul(g, [monomial.sub(t, gl[0]), fl[1]]))
}


// Return the reduced polynomial of reducee by reducer.  That is, if
// one of reducee's bases is divisible by the leading base of reducer
// with respect to the order, the returned polynomial is the result
// of canceling out the term.

function step_reduce(reducee, reducer){
    var term = polynomial.leading_term(reducer), // term = [base, coeff]
        lb = term[0],
        lc = term[1];
    for(var i = 0; i < reducee.length; i++){
        var b = reducee[i][0],
            c = reducee[i][1];
        if(monomial.equal(monomial.lcm(b, lb), b)){
            return polynomial.add(reducee, polynomial.term_mul(reducer, [
                monomial.sub(b, lb), 
                coefficient.div(coefficient.neg(c), lc)
            ]))
        }
    }
}

// Return normalized form of f with respect to reducer, a set of
// polynomials, and order.
function reduce_closure(f, reducers){
    while(true){
        var reduced = null;
        for(var i = 0; i < reducers.length; i++){
            reduced = step_reduce(f, reducers[i]);
            if(reduced){
                f = reduced;
                break
            }
        }
        if(!reduced) return f;
    }
}

// Return a Groebner basis of the ideal generated by given generating
// set of polynomials with respect to the order.

// Be careful, this implementation is very naive.
exports.buchberger = function buchberger(groebner){
    var pairs = []
    for(var i = 0; i < groebner.length; i++){
        for(var j = 0; j < groebner.length; j++){
            if(i === j) continue;
            pairs.push([groebner[i], groebner[j]])
        }
    }

    while(pairs.length > 0){
        var fg = pairs.pop(),
            f = fg[0],
            g = fg[1];
        var h = reduce_closure(s_polynomial(f, g), groebner);
        if(!polynomial.is_zero(h)){
            for(var i = 0; i < groebner.length; i++){
                pairs.push([groebner[i], h])
            }
            groebner.push(h)
        }
    }
    return groebner
}


// Return the reduced Groebner basis constructed from a Groebner
// basis.

// 1) lb(f) divides lb(g) => g is not in reduced Groebner basis
// 2) monic

exports.reduce_groebner = function reduce_groebner(gb){
    var reduced_basis = [];
    var lbc = gb
        .map(k => [polynomial.leading_term(k), k])
        .sort((a, b) => monomial.cmp(a[0], b[0]));

    var lbs = lbc.map(k => k[0]),
        lbr = lbc.map(k => k[1])

    for(var i = 0; i < lbs.length; i++){
        var lbi = lbs[i][0];
        var divisor_found = false;
        for(var j = lbs.length - 1; j > i; j--){
            var lbj = lbs[j][0];
            if(monomial.equal(monomial.lcm(lbj, lbi), lbi)){
                // divisor found
                divisor_found = true
                break
            }
        }
        if(!divisor_found){
            var g = lbr[i];
            var c = lbs[i][1];
            if(coefficient.is_one(c) == false){
                // make it monic
                g = polynomial.scalar_mul(g, coefficient.inv(c))
            }
            reduced_basis.push(g)
        }
    }
    return reduced_basis
}


